# -*- coding: utf-8 -*-
"""3D reconstruction-2ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QeZ2oj5qqjcSzZY3a9xYmXghlkKxwIGg
"""

from google.colab import drive
drive.mount('/content/drive')

pip install ipywidgets nibabel

pip install niwidgets

pip install --upgrade pip setuptools wheel

from tensorflow.keras.models import load_model
import nibabel as nib
#from niwidgets import NiftiWidget
import numpy as np
import matplotlib.pyplot as plt
import cv2

# Define constants
HOUNSFIELD_MIN = -1000
HOUNSFIELD_MAX = 2000
HOUNSFIELD_RANGE = HOUNSFIELD_MAX - HOUNSFIELD_MIN

SLICE_X = True
SLICE_Y = True
SLICE_Z = False

IMAGE_HEIGHT = 40
IMAGE_WIDTH = 80
IMG_SIZE = (IMAGE_HEIGHT, IMAGE_WIDTH)

def normalizeImageIntensityRange(img):
    img[img < HOUNSFIELD_MIN] = HOUNSFIELD_MIN
    img[img > HOUNSFIELD_MAX] = HOUNSFIELD_MAX
    return (img - HOUNSFIELD_MIN)/HOUNSFIELD_RANGE

targetName1 = 'coronacases_org_005'
targetName2= 'coronacases_005'
# Correct the paths based on the dataset folders
targetImagePath = f'/content/drive/MyDrive/lung_dataset/ct_scans/{targetName1}.nii'
targetMaskPath  = f'/content/drive/MyDrive/lung_dataset/lung_mask/{targetName2}.nii'

# Load the NIfTI files
imgTargetNii = nib.load(targetImagePath)
imgMaskNii = nib.load(targetMaskPath)

# Normalize and get data arrays
imgTarget = normalizeImageIntensityRange(imgTargetNii.get_fdata())
imgMask = imgMaskNii.get_fdata()

model = load_model('/content/drive/MyDrive/lung_dataset/updated_model.h5')

"""**Single slicing prediction**"""

def scaleImg(img, height, width):
    return cv2.resize(img, dsize=(width, height), interpolation=cv2.INTER_LINEAR)
sliceIndex = 100

# show input image slice
plt.figure(figsize=(15,15))
imgSlice = imgTarget[sliceIndex,:,:]
imgDimX, imgDimY = imgSlice.shape
imgSliceScaled = scaleImg(imgSlice, IMAGE_HEIGHT, IMAGE_WIDTH)
plt.subplot(1,2,1)
plt.imshow(imgSlice, cmap='gray')
plt.subplot(1,2,2)
plt.imshow(imgSliceScaled, cmap='gray')
plt.show()
imgSlice.shape, imgSliceScaled.shape

# show input mask slice
plt.figure(figsize=(15,15))
maskSlice = imgMask[sliceIndex,:,:]
maskSliceScaled = scaleImg(maskSlice, IMAGE_HEIGHT, IMAGE_WIDTH)
plt.subplot(1,2,1)
plt.imshow(maskSlice, cmap='gray')
plt.subplot(1,2,2)
plt.imshow(maskSliceScaled, cmap='gray')
plt.show()
maskSlice.shape, maskSliceScaled.shape

print(model.input.shape)

# Import necessary libraries
import numpy as np
import matplotlib.pyplot as plt
import cv2

# Define the image resizing function
def scaleImg(img, height, width):
    return cv2.resize(img, dsize=(width, height), interpolation=cv2.INTER_AREA)

# Resize imgSliceScaled to match the model's input shape (128, 128, 1)
IMAGE_HEIGHT, IMAGE_WIDTH = 128, 128
imgSliceResized = scaleImg(imgSliceScaled, IMAGE_HEIGHT, IMAGE_WIDTH)

# Prepare the input for the model
imageInput = imgSliceResized[np.newaxis, :, :, np.newaxis]  # Shape: (1, 128, 128, 1)

# Predict with UNET model
plt.figure(figsize=(15, 15))
maskPredict = model.predict(imageInput)[0, :, :, 0]  # Output shape: (128, 128)

# Rescale mask to match original dimensions
maskPredictScaled = scaleImg(maskPredict, imgDimX, imgDimY)

# Display the results
plt.subplot(1, 2, 1)
plt.imshow(maskPredictScaled, cmap='gray')
plt.title("Rescaled Prediction")

plt.subplot(1, 2, 2)
plt.imshow(maskPredict, cmap='gray')
plt.title("Original Prediction (128x128)")

plt.show()

# Print the shapes for debugging
print("Input shape to model:", imageInput.shape)
print("Prediction shape:", maskPredict.shape)
print("Rescaled mask shape:", maskPredictScaled.shape)

"""
Predicting a full volume"""

def predictVolume(inImg, toBin=True):
    (xMax, yMax, zMax) = inImg.shape

    outImgX = np.zeros((xMax, yMax, zMax))
    outImgY = np.zeros((xMax, yMax, zMax))
    outImgZ = np.zeros((xMax, yMax, zMax))

    cnt = 0.0
    if SLICE_X:
        cnt += 1.0
        for i in range(xMax):
            img = scaleImg(inImg[i,:,:], IMAGE_HEIGHT, IMAGE_WIDTH)[np.newaxis,:,:,np.newaxis]
            tmp = model.predict(img)[0,:,:,0]
            outImgX[i,:,:] = scaleImg(tmp, yMax, zMax)
    if SLICE_Y:
        cnt += 1.0
        for i in range(yMax):
            img = scaleImg(inImg[:,i,:], IMAGE_HEIGHT, IMAGE_WIDTH)[np.newaxis,:,:,np.newaxis]
            tmp = model.predict(img)[0,:,:,0]
            outImgY[:,i,:] = scaleImg(tmp, xMax, zMax)
    if SLICE_Z:
        cnt += 1.0
        for i in range(zMax):
            img = scaleImg(inImg[:,:,i], IMAGE_HEIGHT, IMAGE_WIDTH)[np.newaxis,:,:,np.newaxis]
            tmp = model.predict(img)[0,:,:,0]
            outImgZ[:,:,i] = scaleImg(tmp, xMax, yMax)

    outImg = (outImgX + outImgY + outImgZ)/cnt
    if(toBin):
        outImg[outImg>0.5] = 1.0
        outImg[outImg<=0.5] = 0.0
    return outImg

predImg = predictVolume(imgTarget)

!pip install --upgrade nilearn

import nilearn
print(nilearn.__version__)

!pip uninstall -y nilearn
!pip install nilearn

from nilearn.plotting import plot_anat
import nibabel as nib

# Plot the image statically
plot_anat(imgTargetNii, title="NIfTI Image", display_mode="ortho", cmap="gray")

predImg_nii = nib.Nifti1Image(predImg, affine=np.eye(4))  # Convert numpy array to NIfTI format

# Plot the image statically
plot_anat(predImg_nii, title="Predicted Image", display_mode="ortho", cmap="gray")

"""Convert binary image to mesh"""

from skimage.measure import marching_cubes
vertices,faces,_,_ = marching_cubes(predImg, level=0)

import plotly.graph_objects as go

# Convert the vertices and faces into a plotly mesh
mesh = go.Mesh3d(x=vertices[:, 0], y=vertices[:, 1], z=vertices[:, 2],
                 i=faces[:, 0], j=faces[:, 1], k=faces[:, 2], opacity=0.5)

# Plot the 3D surface
fig = go.Figure(data=[mesh])
fig.update_layout(title="3D Surface Visualization", scene=dict(
    xaxis_title='X', yaxis_title='Y', zaxis_title='Z'))
fig.show()

!pip install stl

!pip uninstall stl -y
!pip install stl

!pip uninstall stl

!pip install numpy-stl

from stl import mesh
import numpy as np

def dataToMesh(vert, faces):
    mm = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))
    for i, f in enumerate(faces):
        for j in range(3):
            mm.vectors[i][j] = vert[f[j]]
    return mm

# Example vertices and faces
vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]])
faces = np.array([[0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]])

# Create the mesh
stl_mesh = dataToMesh(vertices, faces)

# Save the mesh to a file
stl_mesh.save('lung_output.stl')

!pip install trimesh

!pip install nilearn

